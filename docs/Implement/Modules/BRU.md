# BRU (分支解决单元)

## 1. 概述

分支解决单元（BRU）是后端流水线中的关键执行单元，负责：
- 执行分支条件评估
- 计算跳转目标地址
- 处理分支预测错误恢复
- 与其他流水线组件协调控制流变化

BRU 在执行阶段运行，从保留站（RS）接收分支指令，评估实际的分支结果，并与在取指阶段做出的预测进行比较。基于此比较，BRU 要么确认正确的预测，要么为预测错误触发流水线冲刷。

## 2. 接口规范

### 2.1 输入端口

#### 2.1.1 来自保留站（RS）

| 信号名称 | 类型 | 描述 |
|---------|------|------|
| `BRUOp` | Enum | 分支操作类型（BEQ、BNE、BLT、BGE、BLTU、BGEU、JAL、JALR） |
| `Imm` | UInt(32.W) | 用于偏移计算的立即数值 |
| `PC` | UInt(32.W) | 分支指令的程序计数器 |
| `RobID` | UInt(log2Ceil(ROB_SIZE).W) | 重排序缓冲区条目标识符 |
| `Prediction.Taken` | Bool | 预测的分支是否跳转 |
| `Prediction.Target` | UInt(32.W) | 预测的目标 PC |

#### 2.1.2 来自物理寄存器文件（PRF）

| 信号名称 | 类型 | 描述 |
|---------|------|------|
| `ReadData1` | UInt(32.W) | 源寄存器 1 的值（rs1） |
| `ReadData2` | UInt(32.W) | 源寄存器 2 的值（rs2） |

#### 2.1.3 控制信号

| 信号名称 | 类型 | 描述 |
|---------|------|------|
| `Flush` | Bool | 来自 ROB/BRU 的流水线冲刷信号 |
| `Clock` | Clock | 系统时钟 |
| `Reset` | Reset | 系统复位 |

### 2.2 输出端口

#### 2.2.1 全局广播总线（到 Fetcher、RAT、ROB、RS）

| 信号名称 | 类型 | 描述 |
|---------|------|------|
| `BranchFlush` | Bool | 指示分支预测错误需要流水线冲刷 |
| `RedirectPC` | UInt(32.W) | 用于重定向取指的正确目标 PC |
| `SnapshotID` | UInt(4.W) | 用于 RAT 恢复的分支快照标识符 |

#### 2.2.2 公共数据总线（CBD）接口

| 信号名称 | 类型 | 描述 |
|---------|------|------|
| `CBD.RobID` | UInt(log2Ceil(ROB_SIZE).W) | ROB 条目标识符 |
| `CBD.Result` | UInt(32.W) | 结果值（对分支无意义，通常为 PC+4） |
| `CBD.Exception` | ExcPacket | 异常信息（如果有） |

## 3. 功能

### 3.1 分支操作类型

BRU 支持以下分支和跳转操作：

| 操作 | 描述 | 条件计算 | 目标计算 |
|------|------|----------|----------|
| BEQ | 相等则分支 | `Src1 == Src2` | `PC + Imm` |
| BNE | 不相等则分支 | `Src1 != Src2` | `PC + Imm` |
| BLT | 小于则分支（有符号） | `Src1.asSInt < Src2.asSInt` | `PC + Imm` |
| BGE | 大于或等于则分支（有符号） | `Src1.asSInt >= Src2.asSInt` | `PC + Imm` |
| BLTU | 小于则分支（无符号） | `Src1 < Src2` | `PC + Imm` |
| BGEU | 大于或等于则分支（无符号） | `Src1 >= Src2` | `PC + Imm` |
| JAL | 跳转并链接 | 始终为真 | `PC + Imm` |
| JALR | 跳转并链接寄存器 | 始终为真 | `(Src1 + Imm) & ~1` |

### 3.2 条件评估

BRU 根据操作类型评估分支条件：

```scala
val condition = brOp match {
  case BRUOp.BEQ  => src1 === src2
  case BRUOp.BNE  => src1 =/= src2
  case BRUOp.BLT  => src1.asSInt < src2.asSInt
  case BRUOp.BGE  => src1.asSInt >= src2.asSInt
  case BRUOp.BLTU => src1 < src2
  case BRUOp.BGEU => src1 >= src2
  case BRUOp.JAL  => true.B
  case BRUOp.JALR => true.B
}
```

### 3.3 目标地址计算

根据指令类型计算实际目标地址：

```scala
val actualTarget = brOp match {
  case BRUOp.JALR => (src1 + imm) & ~1.U(32.W)  // 清除 JALR 的最低位
  case _         => pc + imm                      // 其他为 PC 相对
}
```

### 3.4 预测比较

BRU 将计算结果与预测进行比较：

```scala
val predictionCorrect = condition === prediction.Taken && actualTarget === prediction.Target
```

### 3.5 分支决议

基于预测比较，BRU 生成适当的控制信号：

#### 3.5.1 预测正确

当预测与实际结果匹配时：
- 生成 `BranchResolve` 信号
- 不需要流水线冲刷
- 清除依赖单元中的分支掩码
- 允许正常指令退休

#### 3.5.2 预测错误（预测错误）

当预测与实际结果不匹配时：
- 生成 `BranchFlush` 信号
- 将 `RedirectPC` 设置为正确的目标地址
- 包含 `SnapshotID` 以标识要恢复哪个分支快照
- 在 Fetcher、RAT、ROB 和 RS 中触发流水线冲刷

## 4. 时序和流水线行为

### 4.1 流水线阶段

BRU 在流水线的**执行阶段**运行：

```
Fetch → Decode → Rename → Dispatch → Issue → Execute (BRU) → Writeback → Commit
```

### 4.2 时序图

```
周期 N：   发射 - RS 将分支指令分派到 BRU
周期 N+1：执行   - BRU 评估条件并计算目标
周期 N+2：广播   - BRU 在 CBD 上广播结果和/或冲刷信号
```

### 4.3 冲刷传播

当检测到预测错误时：
1. **周期 N+1**：BRU 计算实际结果并检测预测错误
2. **周期 N+2**：BRU 广播 `BranchFlush`、`RedirectPC` 和 `SnapshotID`
3. **周期 N+2**：Fetcher 重定向到 `RedirectPC`
4. **周期 N+2**：RAT 从指定快照恢复前端 RAT
5. **周期 N+2**：ROB 清除依赖于错误预测分支的条目
6. **周期 N+2**：RS 清除具有匹配 `BranchMask` 的指令

## 5. 内部架构

### 5.1 主要组件

```
┌─────────────────────────────────────────────────────────────┐
│                        BRU 模块                              │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  条件       │  │   目标      │  │  预测               │ │
│  │  评估器     │  │  计算器     │  │  比较器             │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
│         │                │                    │            │
│         └────────────────┼────────────────────┘            │
│                          ▼                                 │
│                 ┌──────────────────┐                       │
│                 │  决议            │                       │
│                 │  逻辑             │                       │
│                 └──────────────────┘                       │
│                          │                                 │
│         ┌────────────────┼────────────────┐               │
│         ▼                ▼                ▼               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │   CBD       │  │   全局      │  │   结果      │      │
│  │   输出      │  │   冲刷      │  │   寄存器    │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 状态元素

| 寄存器 | 宽度 | 描述 |
|--------|------|------|
| `result_reg` | 32 位 | 存储计算结果用于 CBD 广播 |
| `rob_id_reg` | log2(ROB_SIZE) | 存储用于结果写回的 ROB ID |
| `flush_reg` | 1 位 | 存储冲刷信号用于下一周期广播 |
| `redirect_pc_reg` | 32 位 | 存储重定向 PC 用于下一周期广播 |
| `snapshot_id_reg` | 4 位 | 存储快照 ID 用于下一周期广播 |

### 5.3 控制逻辑

BRU 实现以下控制逻辑：

1. **发射检测**：当 RS 提供有效数据时接受新分支指令
2. **计算**：在同一周期评估条件并计算目标
3. **比较**：将计算结果与预测进行比较
4. **信号生成**：生成适当的冲刷或解决信号
5. **结果存储**：存储结果用于下一周期广播
6. **广播**：在下一周期在适当接口上输出结果

## 6. 与其他模块的交互

### 6.1 与保留站（RS）

- **输入**：接收带有预测信息的解码分支指令
- **输出**：无（直接交互通过 PRF 读端口）

### 6.2 与物理寄存器文件（PRF）

- **输入**：读取源寄存器值用于条件评估
- **输出**：无（写回通过 CBD）

### 6.3 与公共数据总线（CBD）

- **输入**：无
- **输出**：广播分支完成结果用于 ROB 状态更新

### 6.4 与 Fetcher

- **输入**：无
- **输出**：在预测错误时发送 `BranchFlush` 和 `RedirectPC`

### 6.5 与寄存器别名表（RAT）

- **输入**：无
- **输出**：在预测错误时发送 `BranchFlush` 和 `SnapshotID` 用于 RAT 恢复

### 6.6 与重排序缓冲区（ROB）

- **输入**：无
- **输出**：发送 `BranchFlush`、`RedirectPC` 和 `SnapshotID` 用于条目清除

### 6.7 与保留站（RS）

- **输入**：无
- **输出**：发送 `BranchFlush` 和 `BranchMask` 用于指令清除

## 7. 异常处理

### 7.1 分支指令异常

BRU 可能处理以下异常：

| 异常类型 | 原因 | 处理 |
|----------|------|------|
| 非法指令 | 无效的 BRUOp | 通过 CBD 将异常传递给 ROB |
| 未对齐跳转 | JALR 目标未对齐到 2 字节 | 生成异常，传递给 ROB |

### 7.2 异常传播

当发生异常时：
1. 设置 `CBD.Exception.valid = true`
2. 将 `CBD.Exception.cause` 设置为适当的异常代码
3. 将 `CBD.Exception.tval` 设置为故障地址（如果适用）
4. 在 CBD 上广播用于 ROB 处理
5. 不生成分支冲刷（ROB 将处理异常）

## 8. 设计考虑

### 8.1 性能考虑

1. **单周期评估**：条件和目标在一个周期内计算以最小化延迟
2. **早期广播**：结果存储并在下一周期广播以避免关键路径问题
3. **并行计算**：条件和目标并行计算以提高速度

### 8.2 正确性考虑

1. **精确异常**：确保通过 ROB 精确处理异常
2. **原子冲刷**：确保所有依赖单元同时接收冲刷信号
3. **快照一致性**：确保 SnapshotID 正确标识分支快照

### 8.3 资源利用

1. **最小存储**：仅保存结果所需的基本寄存器
2. **共享 PRF 端口**：使用现有 PRF 读端口（无专用 BRU PRF）
3. **广播优化**：使用专用全局广播线路进行冲刷信号

## 9. 实现说明

### 9.1 Chisel 实现指南

1. 使用 `Enum` 作为 BRUOp 以确保类型安全
2. 使用 `MuxLookup` 或 `switch/is` 进行操作选择
3. 使用组合逻辑实现条件评估
4. 寄存器输出以实现时序收敛
5. 正确处理所有状态元素的复位

### 9.2 测试考虑

测试用例应覆盖：
1. 所有分支操作类型
2. 正确预测场景
3. 错误预测场景（跳转/不跳转）
4. 错误目标场景
5. 边界情况（溢出、下溢）
6. 异常情况（非法指令、未对齐跳转）

## 10. 总结

BRU 是一个关键执行单元，它：
- 评估分支条件并计算目标地址
- 将实际结果与预测进行比较
- 通过流水线冲刷处理预测错误恢复
- 与 Fetcher、RAT、ROB 和 RS 协调控制流变化
- 通过 ROB 维护精确异常处理

BRU 在单个周期内进行计算，并使用寄存器输出阶段进行广播，确保最小的分支解决延迟，同时保持正确的流水线行为。
